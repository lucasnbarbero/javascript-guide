---
title: ECMAScript 6
---

ES6 trajo consigo numerosos cambios significativos al lenguaje JavaScript. A continuaciÃ³n, exploraremos algunas de las caracterÃ­sticas mÃ¡s destacadas:

## Arrow functions â¡ï¸

Las funciones **arrow** simplifican la sintaxis de las funciones en JavaScript.

```js
// ES5
var data = [{ ... }, { ... }, { ... }, ...];
data.forEach(function (elem) {
  console.log(elem);
});
```

En ES6, lo anterior se reemplaza con una sintaxis mÃ¡s limpia:

```js
// ES6
var data = [{ ... }, { ... }, { ... }, ...];
data.forEach((elem) => {
  console.log(elem);
});
```

## Clases ğŸ“š

ES6 introduce clases al lenguaje, lo que facilita el uso del paradigma orientado a objetos. Aunque las clases son azÃºcar sintÃ¡ctico (_sugar syntax_), se basan en los prototipos subyacentes de JavaScript.

```js
class LibroTecnico extends Libro {
  constructor(tematica, paginas) {
    super(tematica, paginas);
    this.capitulos = [];
    this.precio = "";
  }
  metodo() {
    // ...
  }
}
```

## `this` ğŸ”

El contexto de `this` en JavaScript siempre ha sido un desafÃ­o. En versiones anteriores, era comÃºn asignarlo a otra variable como `that` para evitar problemas:

```js
// ES3
var obj = {
  foo: function () { ... },
  bar: function () {
    var that = this;
    document.addEventListener("click", function (e) {
      that.foo();
    });
  },
};
```

Con las funciones **arrow**, el contexto de `this` se maneja automÃ¡ticamente:

```js
// ES6
var obj = {
  foo: function () { ... },
  bar: function () {
    document.addEventListener("click", (e) => this.foo());
  },
};
```

`let` y `const` ğŸ›¡ï¸

`let`
Permite declarar variables con un alcance limitado al bloque en el que se define:

```js
// ES5
(function () {
  if (true) {
    var x = "hola mundo";
  }
  console.log(x); // "hola mundo" (var es funcionalmente global en este caso)
})();

// ES6
(function () {
  if (true) {
    let x = "hola mundo";
  }
  console.log(x); // Error: x no estÃ¡ definida fuera del bloque
})();
```

`const`
Define constantes de solo lectura:

```js
(function () {
  const PI = 3.14;
  PI = 3.14159; // Error: no se puede reasignar un valor a una constante
})();
```

## Template Strings âœ¨

Las **template strings** facilitan la creaciÃ³n de cadenas dinÃ¡micas y multilÃ­nea:

- **InterpolaciÃ³n**:

```js
let nombre = "Jonathan";
console.log(`Hola, ${nombre}`); // Hola, Jonathan
```

- **Cadenas multilÃ­nea**:

```js
let mensaje = `No es quiÃ©n eres en el interior,  
tus actos son los que te definen... Batman`;
console.log(mensaje);
```

- **Funciones etiquetadas (_tagged templates_)**:

```js
const etiqueta = (cadena, variable) => {
  console.log(`${cadena[0]}${variable}`);
};
etiqueta`Hola ${"Ulises"}`; // Hola Ulises
```

## DesestructuraciÃ³n ğŸ§©

La desestructuraciÃ³n permite extraer valores de objetos o arrays y asignarlos a variables de manera mÃ¡s concisa y legible:

#### Para objetos

```js
const persona = { nombre: "Juan", edad: 30 };
const { nombre, edad } = persona;
console.log(nombre); // "Juan"
console.log(edad); // 30
```

#### Para arrays

```js
const numeros = [1, 2, 3];
const [a, b] = numeros;
console.log(a); // 1
console.log(b); // 2
```

## Spread Operator y Rest Parameters ğŸŒ

#### Spread Operator (`...`)

Permite expandir elementos de un array u objeto en otras estructuras

```js
// Spread en arrays
const array1 = [1, 2, 3];
const array2 = [...array1, 4, 5];
console.log(array2); // [1, 2, 3, 4, 5]

// Spread en objetos
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
console.log(obj2); // { a: 1, b: 2, c: 3 }
```

#### Rest Parameters (`...`)

Permite capturar mÃºltiples valores en un Ãºnico parÃ¡metro

```js
// En funciones
function suma(...valores) {
  return valores.reduce((acc, val) => acc + val, 0);
}
console.log(suma(1, 2, 3)); // 6
```

## MÃ³dulos ğŸ“¦

ES6 introduce el concepto de **mÃ³dulos**, lo que permite dividir el cÃ³digo en archivos mÃ¡s pequeÃ±os, manteniendo una estructura de importaciÃ³n y exportaciÃ³n. Esto mejora la organizaciÃ³n y reutilizaciÃ³n del cÃ³digo.

#### Exportar un mÃ³dulo

```js
// archivo.js
export const saludo = "Hola Mundo";
export function saludar() {
  console.log(saludo);
}
```

#### Importar un mÃ³dulo

```js
// app.js
import { saludo, saludar } from "./archivo.js";
console.log(saludo); // "Hola Mundo"
saludar(); // "Hola Mundo"
```

## Promesas ğŸ¤

Las **promesas** permiten manejar operaciones asÃ­ncronas de una manera mÃ¡s legible y estructurada que los callbacks, evitando el "callback hell".

```js
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("OperaciÃ³n exitosa");
  } else {
    reject("OperaciÃ³n fallida");
  }
});

promise
  .then((message) => console.log(message)) // "OperaciÃ³n exitosa"
  .catch((message) => console.log(message)); // En caso de error
```

## SÃ­mbolos ğŸ”‘

Los **sÃ­mbolos** son un nuevo tipo primitivo que se utiliza para crear identificadores Ãºnicos para propiedades de objetos, lo que permite evitar colisiones de nombres.

```js
const id = Symbol("id");
const persona = {
  [id]: 123,
};
console.log(persona[id]); // 123
```

## Iteradores y Generadores ğŸ”„

#### Iteradores

Los iteradores son objetos que permiten recorrer colecciones de datos (como arrays, strings, mapas, etc.) de manera secuencial.

```js
const array = [10, 20, 30];
const iterador = array[Symbol.iterator]();
console.log(iterador.next().value); // 10
console.log(iterador.next().value); // 20
```

#### Generadores

Los generadores son una funciÃ³n especial que puede devolver mÃºltiples valores de manera perezosa (lazy evaluation). Utilizan la palabra clave `function*` y `yield`:

```js
function* contar() {
  yield 1;
  yield 2;
  yield 3;
}

const generador = contar();
console.log(generador.next().value); // 1
console.log(generador.next().value); // 2
console.log(generador.next().value); // 3
```

## Mapas y Sets ğŸ—ºï¸

#### Mapas

Los **Mapas** son estructuras de datos que permiten almacenar pares de claves y valores, similar a los objetos, pero con la diferencia de que las claves pueden ser de cualquier tipo.

```js
let mapa = new Map();
mapa.set("nombre", "Juan");
mapa.set("edad", 30);
console.log(mapa.get("nombre")); // "Juan"
```

#### Sets

Los **Sets** permiten almacenar valores Ãºnicos (sin duplicados).

```js
let conjunto = new Set();
conjunto.add(1);
conjunto.add(2);
conjunto.add(2); // No se aÃ±adirÃ¡, porque 2 ya estÃ¡ en el set
console.log(conjunto); // Set { 1, 2 }
```

---

## ConclusiÃ³n ğŸ¯

ES6 trajo una serie de mejoras y caracterÃ­sticas que han optimizado el desarrollo en JavaScript. Estas novedades han hecho que el lenguaje sea mÃ¡s moderno, eficiente y fÃ¡cil de trabajar, brindando herramientas poderosas para manejar tanto cÃ³digo sincrÃ³nico como asincrÃ³nico. Â¡Adelante con ES6! ğŸš€
