---
title: Herencia
---

import { Aside } from "@astrojs/starlight/components";

La herencia de clase es el modo para que una clase extienda a otra. ğŸ—ï¸
De esta manera podemos aÃ±adir nueva funcionalidad a la ya existente. ğŸš€

## ğŸ“š La palabra clave `extends`

Digamos que tenemos la clase `Animal`

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} corre a una velocidad de ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} se queda quieto.`);
  }
}

let animal = new Animal("Mi animal");
```

Y nos gustarÃ­a crear otra clase `Rabbit`. ğŸ‡

Como los conejos son animales, la clase `Rabbit` deberÃ­a basarse en `Animal` y asÃ­ tener acceso a mÃ©todos animales, para que los conejos puedan hacer lo que los animales "genÃ©ricos" pueden hacer.

La sintaxis para extender otra clase es: `class Hijo extends Padre`. ğŸ› ï¸

Construyamos la clase `Rabbit` que herede de `Animal`:

```js
class Rabbit extends Animal {
  hide() {
    alert(`Â¡${this.name} se esconde!`);
  }
}

let rabbit = new Rabbit("Conejo Blanco");

rabbit.run(5); // Conejo Blanco corre a una velocidad de 5.
rabbit.hide(); // Â¡Conejo Blanco se esconde!
```

Los objetos de la clase `Rabbit` tienen acceso a los mÃ©todos de `Rabbit`, como `rabbit.hide()`, y tambiÃ©n a los mÃ©todos `Animal`, como `rabbit.run()`. ğŸŒŸ

<Aside type="tip" title="Cualquier expresiÃ³n estÃ¡ permitida de extends">
  La sintaxis de clase permite especificar no solo una clase, sino cualquier
  expresiÃ³n despuÃ©s de `extends`.

Por ejemplo, una llamada a funciÃ³n que genera la clase padre:

```js
function f(phrase) {
  return class {
    sayHi() {
      alert(phrase);
    }
  };
}

class User extends f("Hola") {}

new User().sayHi(); // Hola
```

Observa que `class User` hereda del resultado de `f("Hola")`.

Esto puede ser Ãºtil para patrones de programaciÃ³n avanzados cuando usamos funciones para generar clases dependiendo de muchas condiciones y podamos heredar de ellas. ğŸ› ï¸

</Aside>

---

## ğŸ”„ Sobreescribir un mÃ©todo

Ahora avancemos y sobrescribamos un mÃ©todo. Por defecto, todos los mÃ©todos que no estÃ¡n especificados en la clase `Rabbit` se toman directamente "tal cual" de la clase `Animal`. ğŸ¾

Pero si especificamos nuestro propio mÃ©todo `stop()` en `Rabbit`, es el que se utilizarÃ¡ en su lugar:

```js
class Rabbit extends Animal {
  stop() {
    // ...esto se usarÃ¡ para rabbit.stop()
    // en lugar de stop() de la clase Animal
  }
}
```

Sin embargo, no siempre queremos reemplazar totalmente un mÃ©todo padre sino construir sobre Ã©l, modificarlo o ampliar su funcionalidad. Hacemos algo con nuestro mÃ©todo, pero queremos llamar al mÃ©todo padre antes, despuÃ©s o durante el proceso. âœ¨

Las clases proporcionan la palabra clave `super` para eso.

Por ejemplo, hagamos que nuestro conejo se oculte automÃ¡ticamente cuando se detenga:

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} corre a una velocidad de ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} se queda quieto.`);
  }
}

class Rabbit extends Animal {
  hide() {
    alert(`Â¡${this.name} se esconde!`);
  }

  stop() {
    super.stop(); // llama el stop padre
    this.hide(); // y luego hide
  }
}

let rabbit = new Rabbit("Conejo Blanco");

rabbit.run(5); // Conejo Blanco corre a una velocidad de 5.
rabbit.stop(); // Conejo Blanco se queda quieto. Â¡Conejo Blanco se esconde!
```

Ahora `Rabbit` tiene el mÃ©todo `stop` que llama al padre `super.stop()` en el proceso.

---

## ğŸ”§ Sobreescribir un constructor

Con los constructores se pone un poco complicado. ğŸ¤”

Hasta ahora, `Rabbit` no tenÃ­a su propio `constructor`.

Si una clase extiende otra clase y no tiene `constructor`, se genera el siguiente `constructor` "vacÃ­o":

```js
class Rabbit extends Animal {
  // es generado por extender la clase sin constructor propio
  constructor(...args) {
    super(...args);
  }
}
```

Como podemos ver, bÃ¡sicamente llama al `constructor` padre pasÃ¡ndole todos los argumentos. Esto sucede si no escribimos un constructor propio.

Ahora agreguemos un constructor personalizado a `Rabbit`. EspecificarÃ¡ `earLength` ademÃ¡s de `name`:

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// No funciona!
let rabbit = new Rabbit("Conejo Blanco", 10); // Error: this no estÃ¡ definido.
```

ğŸ›‘ **Tenemos un error. Ahora no podemos crear conejos. Â¿QuÃ© saliÃ³ mal?**

La respuesta corta es:

- **Los constructores en las clases heredadas deben llamar a `super(...)`, y (Â¡!) hacerlo antes de usar `this`.**

â€¦Â¿Pero por quÃ©? Â¿QuÃ© estÃ¡ pasando aquÃ­? De hecho, el requisito parece extraÃ±o.

En JavaScript, hay una distinciÃ³n entre una funciÃ³n constructora de una clase heredera (llamada â€œconstructor derivadoâ€) y otras funciones.

- Un constructor derivado tiene una propiedad interna especial `[[ConstructorKind]]:"derived"`.
- Cuando una funciÃ³n regular se ejecuta con `new`, crea un objeto vacÃ­o y lo asigna a `this`.
- Pero cuando se ejecuta un constructor derivado, no hace esto. Espera que el constructor padre haga este trabajo.

Entonces, un constructor derivado debe llamar a `super` para ejecutar su constructor padre (base), de lo contrario no se crearÃ¡ el objeto para `this`.

Para que el constructor `Rabbit` funcione, necesita llamar a `super()` antes de usar `this`, como aquÃ­:

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// todo bien ahora
let rabbit = new Rabbit("Conejo Blanco", 10);
alert(rabbit.name); // Conejo Blanco
alert(rabbit.earLength); // 10
```

Â¡Ahora funciona perfectamente! ğŸš€
