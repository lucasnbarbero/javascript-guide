---
title: Funciones
sidebar:
  order: 8
  badge:
    text: ES6
    variant: caution
---

import { Aside, Badge } from "@astrojs/starlight/components";

En JavaScript, las funciones son bloques de cÃ³digo diseÃ±ados para realizar tareas especÃ­ficas. Son uno de los pilares fundamentales de la programaciÃ³n, ya que permiten escribir cÃ³digo modular, reutilizable y fÃ¡cil de mantener. ğŸ’¡

Seguramente ya has usado funciones integradas como `alert(message)`, `prompt(message, default)` o `confirm(question)`. Â¡Pero tambiÃ©n puedes crear tus propias funciones! ğŸš€

## DeclaraciÃ³n de funciones

Para declarar una funciÃ³n, usa la palabra clave `function` seguida del nombre de la funciÃ³n, parÃ©ntesis `()` (que pueden contener parÃ¡metros) y un bloque de cÃ³digo `{}`:

```js
function showMessage() {
  alert("Â¡Hola a todos! ğŸ‘‹");
}
```

<Aside type="note" title="Nota">
  Los parÃ©ntesis pueden estar vacÃ­os si no necesitas parÃ¡metros. El bloque `{}`
  define lo que la funciÃ³n harÃ¡ cuando sea llamada.
</Aside>

### Con parÃ¡metros

Las funciones pueden aceptar **parÃ¡metros**, que son valores que pasan informaciÃ³n a la funciÃ³n:

```js
function showMessage(message) {
  alert(message);
}
```

## EjecuciÃ³n de una funciÃ³n

Una vez declarada, se llama a la funciÃ³n escribiendo su nombre seguido de parÃ©ntesis. Si tiene parÃ¡metros, pasa los valores dentro de ellos:

```js
showMessage("Â¡Hola a todos! ğŸ‰");
showMessage("Â¡Hasta la prÃ³xima! ğŸ‘‹");
```

âœ¨ **Ventaja clave**: Evitas duplicar cÃ³digo. Si necesitas cambiar cÃ³mo funciona, Â¡solo debes modificar la funciÃ³n! ğŸ› ï¸

### ParÃ¡metros por defecto <Badge text="ES6" variant="caution" />

A partir de ES6, puedes asignar valores predeterminados a los parÃ¡metros. Esto asegura que la funciÃ³n pueda funcionar incluso si no recibe ciertos argumentos:

```js
function saludar(nombre = "usuario") {
  alert(`Â¡Hola, ${nombre}! ğŸ¤—`);
}

saludar(); // Â¡Hola, usuario!
saludar("Lucas"); // Â¡Hola, Lucas!
```

## Retorno de valores

Una funciÃ³n puede **devolver un resultado** al llamarla, usando la palabra clave `return`. Esto permite que otras partes del cÃ³digo utilicen el valor devuelto:

```js
function sum(a, b) {
  return a + b;
}

let result = sum(2, 3);
alert(result); // 5
```

<Aside type="note" title="Nota">
  Cuando `return` se ejecuta, la funciÃ³n se detiene inmediatamente. Si el cÃ³digo
  llega a esa lÃ­nea, lo demÃ¡s se ignora.
</Aside>

## Expresiones de funciÃ³n

En JavaScript, ademÃ¡s de declarar funciones de forma clÃ¡sica, puedes crear funciones usando **expresiones de funciÃ³n**. Estas son funciones anÃ³nimas asignadas a una variable.

```js
const sayHello = function () {
  alert("Â¡Hola desde una expresiÃ³n! ğŸŒŸ");
};

sayHello(); // Â¡Hola desde una expresiÃ³n!
```

âš¡ **Diferencia clave**: Las expresiones de funciÃ³n **no se elevan** (hoisting). Debes definirlas antes de llamarlas.

## Callbacks

Un callback es una funciÃ³n pasada como argumento a otra funciÃ³n y ejecutada despuÃ©s de completar alguna operaciÃ³n. Son esenciales para manejar asincronÃ­a. ğŸ’»

```js
function greet(name, callback) {
  console.log(`Hola, ${name}!`);
  callback();
}

greet("Lucas", () => console.log("AdiÃ³s ğŸ‘‹"));
```

## Funciones Flecha <Badge text="ES6" variant="caution" />

Las **funciones flecha**, tambiÃ©n conocidas como _**arrow functions**_ son una forma moderna, âœ‚ï¸ mÃ¡s corta y ğŸ’¡ mÃ¡s clara de escribir funciones en JavaScript. Su sintaxis es sÃºper elegante y se reconocen fÃ¡cilmente gracias a su caracterÃ­stica flecha `=>`.

```js
let func = (arg1, arg2, ..., argN) => expresiÃ³n;
```

#### ğŸ” Â¿QuÃ© significa esto?

Es como decir: "Crea una funciÃ³n llamada `func` que reciba los parÃ¡metros `arg1, arg2, ..., argN`, evalÃºe la `expresiÃ³n` a la derecha de la flecha y devuelva el resultado automÃ¡ticamente".

Es bÃ¡sicamente una forma abreviada de escribir:

```js
let func = function(arg1, arg2, ..., argN) {
  return expresiÃ³n;
};
```

#### Un ejemplo prÃ¡ctico

Supongamos que queremos sumar dos nÃºmeros. Con una funciÃ³n flecha, podrÃ­amos escribir:

```js
let sum = (a, b) => a + b;

// Es lo mismo que escribir:
// let sum = function(a, b) {
//   return a + b;
// };

alert(sum(1, 2)); // 3
```

ğŸ‘€ Â¿QuÃ© estÃ¡ pasando aquÃ­?
`(a, b) => a + b` define una funciÃ³n que recibe dos argumentos, `a y b`. Luego, evalÃºa la expresiÃ³n `a + b` y devuelve el resultado automÃ¡ticamente. Â¡AsÃ­ de simple y directo!

### Funciones Flecha MultilÃ­nea

Hasta ahora, hemos visto ejemplos simples que caben en una sola lÃ­nea. Pero Â¿quÃ© pasa si nuestra funciÃ³n necesita varias lÃ­neas de cÃ³digo? En ese caso, podemos usar llaves `{}` para envolver las instrucciones y aÃ±adir un `return` explÃ­cito (como en las funciones tradicionales).

```js
let sum = (a, b) => {
  // AquÃ­ abrimos una funciÃ³n multilÃ­nea
  let result = a + b;
  return result; // Necesitamos usar "return" cuando hay llaves
};

alert(sum(1, 2)); // 3
```

ğŸ”‘ **Recuerda**: `Si usas llaves {}`, necesitas incluir un `return` explÃ­cito para devolver el resultado.

## Scope y Closures <Badge text="ES6" variant="caution" />

Entender el scope y los closures es clave para escribir cÃ³digo eficiente y moderno en JavaScript. ğŸ§ ğŸ’» A partir de ES6, estos conceptos se volvieron mÃ¡s claros gracias a la introducciÃ³n de nuevas herramientas como `let` y `const`. Â¡Veamos todo esto en acciÃ³n! ğŸš€

### Scope

El **scope** (o Ã¡mbito) se refiere al contexto donde las variables existen y son accesibles. JavaScript organiza el scope en tres tipos principales:

- **Scope Global** ğŸŒ
- **Scope Local** ğŸ 
- **Scope de Bloque** ğŸ“¦ (introducido en ES6 con `let` y `const`)

#### ğŸŒ Scope Global

Las variables declaradas fuera de cualquier funciÃ³n o bloque pertenecen al scope global. Esto significa que puedes acceder a ellas desde cualquier lugar del cÃ³digo.

```js
let globalVar = "Soy una variable global";

function showGlobalVar() {
  alert(globalVar);
}

showGlobalVar(); // Soy una variable global
```

<Aside type="tip" title="Tip">
  Evita llenar el scope global con demasiadas variables para mantener el cÃ³digo
  organizado.
</Aside>

#### ğŸ  Scope Local

Las variables declaradas dentro de una funciÃ³n tienen un alcance limitado a esa funciÃ³n. No puedes acceder a ellas desde fuera.

```js
function myFunction() {
  let localVar = "Soy una variable local";
  console.log(localVar);
}

myFunction(); // Soy una variable local
console.log(localVar); // âŒ Error: localVar no estÃ¡ definida
```

#### ğŸ“¦ Scope de Bloque

A partir de ES6, puedes usar `let` y `const` para declarar variables con **scope de bloque**. Esto significa que solo estÃ¡n disponibles dentro del bloque donde se declaran.

```js
if (true) {
  let blockVar = "Soy una variable de bloque";
  console.log(blockVar); // Soy una variable de bloque
}

console.log(blockVar); // âŒ Error: blockVar no estÃ¡ definida
```

<Aside type="note" title="Nota">
  A diferencia de `var`, que ignora el scope de bloque, `let` y `const` respetan
  el alcance limitado. Â¡Ãšsalos siempre que puedas! ğŸ› ï¸
</Aside>

#### â›“ï¸ Scope Anidado

Los scopes pueden estar anidados. Una funciÃ³n puede acceder a las variables definidas en su scope externo.

```js
let outerVar = "Estoy fuera";

function outerFunction() {
  let innerVar = "Estoy dentro";

  function innerFunction() {
    console.log(outerVar); // Estoy fuera
    console.log(innerVar); // Estoy dentro
  }

  innerFunction();
}

outerFunction();
```

ğŸ§© **Â¿QuÃ© aprendimos?** Las funciones "heredan" variables de su scope superior, pero no al revÃ©s.

### Closures

Un **closure** es una funciÃ³n que "recuerda" el entorno donde fue creada, incluyendo las variables del scope externo. Esto sucede incluso despuÃ©s de que la funciÃ³n haya terminado de ejecutarse.

```js
function crearSaludador(nombre) {
  return function () {
    console.log(`Â¡Hola, ${nombre}!`);
  };
}

const saludarLucas = crearSaludador("Lucas");
saludarLucas(); // Â¡Hola, Lucas!

const saludarMaria = crearSaludador("Maria");
saludarMaria(); // Â¡Hola, Maria!
```

ğŸ“‹ Â¿QuÃ© pasÃ³ aquÃ­?

1. FunciÃ³n Externa: `crearSaludador` toma un parÃ¡metro `nombre` y devuelve una nueva funciÃ³n.
2. FunciÃ³n Interna (closure): La funciÃ³n devuelta "recuerda" el valor de `nombre` del momento en que fue creada.
3. Ejecutar el Closure: Cada vez que llamamos a las funciones devueltas (`saludarLucas`, `saludarMaria`), estas utilizan el valor de `nombre` que quedÃ³ guardado en su entorno.

#### Ejemplo de contador

```js
function crearContador() {
  let contador = 0;

  return function () {
    contador++;
    console.log(contador);
  };
}

const contador1 = crearContador();
contador1(); // 1
contador1(); // 2
contador1(); // 3

const contador2 = crearContador();
contador2(); // 1
contador2(); // 2
```

âœ¨ **Â¿Por quÃ© es Ãºtil?** Este patrÃ³n es ideal para guardar un estado privado en funciones, evitando conflictos con otras partes del cÃ³digo.

## Spread y Rest Operators <Badge text="ES6" variant="caution" />

JavaScript tiene funciones nativas sÃºper Ãºtiles que aceptan un nÃºmero arbitrario de argumentos. Â¡Veamos algunos ejemplos! ğŸš€

- ğŸ§® `Math.max(arg1, arg2, ..., argN)` â€“ Devuelve el argumento mÃ¡s grande.
- ğŸ“¦ `Object.assign(dest, src1, ..., srcN)` â€“ Copia las propiedades de src1...N en dest.
- ...Â¡Y muchos mÃ¡s! ğŸ‰

### âœ¨ ParÃ¡metros Rest `...`

Cuando llamas a una funciÃ³n, puedes pasarle cualquier cantidad de argumentos, Â¡y JavaScript no se quejarÃ¡! ğŸ’¡

Por ejemplo:

```js
function sum(a, b) {
  return a + b;
}

alert(sum(1, 2, 3, 4, 5)); // 3
```

âš ï¸ AquÃ­ solo se toman los dos primeros argumentos. Â¿Y el resto?

Usamos `...` para capturar todos los argumentos restantes en un **array**:

```js
function sumAll(...args) {
  let sum = 0;

  for (let arg of args) {
    sum += arg;
  }

  return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6
```

#### ğŸ­ Un ejemplo mÃ¡s interesante

Podemos capturar los primeros parÃ¡metros como variables y el resto como un array

```js
function showName(firstName, lastName, ...titles) {
  alert(`${firstName} ${lastName}`); // Lucas Barbero
  alert(titles[0]); // Curso JavaScript
  alert(titles[1]); // 2025
  alert(titles.length); // 2
}

showName("Lucas", "Barbero", "Curso JavaScript", "2025");
```

<Aside type="caution" title="Regla importante">
Los parÃ¡metros rest **deben** ir al final:

```js
function showName(...titles, firstName, lastName) {
  // âŒ Error: los parÃ¡metros rest deben ir al final
}
```

</Aside>

### ğŸŒˆ Operador Spread `...`

Si los parÃ¡metros rest juntan argumentos en un array, el operador **spread** (`...`) hace lo contrario: Â¡expande un array en una lista de argumentos! ğŸª„

Por ejemplo, si queremos obtener el valor mÃ¡ximo de un array

```js
let numbers = [1, 5, 2, 9, 3, 7];
alert(Math.max(...numbers)); // 9
```

Â¡Incluso podemos combinarlo con valores normales o con otros arrays! ğŸ¤¯

```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(0, ...arr1, 2, ...arr2, 25)); // 25
```

#### ğŸ§© Â¿Y para combinar arrays?

Â¡FÃ¡cil!

```js
let merged = [0, ...arr1, 2, ...arr2];
alert(merged); // 0, 1, -2, 3, 2, 8, 3, -8
```

TambiÃ©n funciona con cadenas, convirtiÃ©ndolas en arrays de caracteres:

```js
let str = "Hola";
alert([...str]); // ['H', 'o', 'l', 'a']
```

### ğŸ› ï¸ Copia de Objetos y Arrays

El operador spread es genial para crear copias. Â¡Mucho mÃ¡s corto y limpio que `Object.assign`! ğŸ’¡

#### Copia de un array

```js
let arr = [1, 2, 3];
let arrCopy = [...arr];

alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true
alert(arr === arrCopy); // false
```

#### Copia de un objeto

```js
let obj = { a: 1, b: 2 };
let objCopy = { ...obj };

alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true
alert(obj === objCopy); // false
```

Â¡AdemÃ¡s, las copias son independientes! Cambiar el original no afecta la copia. ğŸ™Œ
