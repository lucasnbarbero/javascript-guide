---
title: Export e Import
---

import { Aside } from "@astrojs/starlight/components";

Las directivas `export` e `import` son esenciales para trabajar con mÃ³dulos en JavaScript. En este artÃ­culo, exploraremos a fondo cÃ³mo utilizarlas, con ejemplos prÃ¡cticos que harÃ¡n que domines este tema como un profesional. ğŸš€

ğŸ·ï¸ Export antes de las sentencias
Cualquier cosa en JavaScript puede "etiquetarse" como exportable: variables, funciones, clases, Â¡tÃº eliges! Solo necesitas anteponer export. Por ejemplo:

```js
// Exportar un array
export let months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

// Exportar una constante
export const MODULES_BECAME_STANDARD_YEAR = 2015;

// Exportar una clase
export class User {
  constructor(name) {
    this.name = name;
  }
}
```

<Aside type="tip">
  No necesitas un punto y coma despuÃ©s de exportar una clase o funciÃ³n porque
  siguen siendo declaraciones, no expresiones. Â¡Menos confusiÃ³n! ğŸ˜„
</Aside>

## âœ‚ï¸ Export por separado

No es obligatorio exportar algo justo al declararlo. Puedes exportar todo junto mÃ¡s abajo en el archivo. Ejemplo:

```js
// ğŸ“ say.js
function sayHi(user) {
  alert(`Hello, ${user}!`);
}

function sayBye(user) {
  alert(`Bye, ${user}!`);
}

// Exportar al final
export { sayHi, sayBye };
```

Esto te permite estructurar tu cÃ³digo primero y luego decidir quÃ© quieres hacer pÃºblico. ğŸ§

## ğŸŒŒ Importar todo con `import *`

Â¿Demasiadas cosas para importar? Â¡AgrÃºpalas en un solo objeto! AsÃ­:

```js
// ğŸ“ main.js
import * as say from "./say.js";

say.sayHi("John"); // Hello, John!
say.sayBye("John"); // Bye, John!
```

#### ğŸ“‹ Ventajas de importar explÃ­citamente:

1. Usas nombres mÃ¡s cortos: `sayHi()` en lugar de say.`sayHi()`.
2. Tienes un panorama mÃ¡s claro de lo que estÃ¡s usando y dÃ³nde. Esto ayuda mucho en la refactorizaciÃ³n.

## ğŸ§© Importar y exportar con alias

Â¿Necesitas cambiar el nombre de algo para hacerlo mÃ¡s claro? Usa `as`:

```js
// ğŸ“ main.js
import { sayHi as hi, sayBye as bye } from "./say.js";

hi("John"); // Hello, John!
bye("John"); // Bye, John!
```

Lo mismo aplica al exportar:

```js
// ğŸ“ say.js
export { sayHi as hi, sayBye as bye };
```

Ahora, al importar, puedes usar estos nombres mÃ¡s amigables. ğŸŒŸ

## â­ Export default: El especial

Cuando un mÃ³dulo tiene una "estrella principal", como una clase o funciÃ³n que representa su propÃ³sito, usamos `export default`:

```js
// ğŸ“ user.js
export default class User {
  constructor(name) {
    this.name = name;
  }
}
```

La gran ventaja: no necesitas llaves al importar, y puedes nombrarla como quieras:

```js
// ğŸ“ main.js
import User from "./user.js";

new User("John");
```

Â¡SÃºper limpio y fÃ¡cil de usar! ğŸ‰

## ğŸ¤ Exportaciones con nombre vs default

| Export con nombre         | Export default              |
| ------------------------- | --------------------------- |
| `export class User {...}` | `export default class User` |
| `import { User }`         | `import User`               |

<Aside type="caution" title="Cuidado">
  Mientras las exportaciones con nombre son claras y obligan a usar nombres
  exactos, las default pueden ser renombradas al importar. Esto podrÃ­a llevar a
  inconsistencias si no tienes cuidado. ğŸ¤”
</Aside>

## ğŸ”„ ReexportaciÃ³n: Modularizando como un pro

La reexportaciÃ³n te permite organizar tu cÃ³digo en mÃ³dulos mÃ¡s pequeÃ±os, exponiendo solo lo necesario desde un punto central. Ejemplo:

```js
// ğŸ“ auth/index.js
export { login, logout } from "./user.js";
export { default as User } from "./user.js";
```

Ahora, quien quiera usar tu paquete puede hacerlo de forma sencilla:

```js
import { login, logout } from "auth/index.js";
import User from "auth/index.js";
```

ğŸ—‚ï¸ Este enfoque es perfecto para proyectos grandes con muchas dependencias internas. Â¡OrganizaciÃ³n al mÃ¡ximo! ğŸš€
