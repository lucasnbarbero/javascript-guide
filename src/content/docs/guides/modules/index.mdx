---
title: MÃ³dulos, introducciÃ³n
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

Imagina que tu aplicaciÃ³n esta creciendo ğŸš€.Cuando eso pasa, es comÃºn querer dividir el cÃ³digo en pequeÃ±os archivos mÃ¡s manejables, llamados **mÃ³dulos**. Cada mÃ³dulo tiene una misiÃ³n: puede ser una clase o un conjunto de funciones para resolver un propÃ³sito especÃ­fico. ğŸ“‚âœ¨

Durante muchos aÃ±os, JavaScript viviÃ³ sin una sintaxis de mÃ³dulos integrada en el lenguaje. Â¿Por quÃ©? Porque en sus inicios, los scripts eran pequeÃ±itos y sencillos. ğŸ£ Pero, con el tiempo, los proyectos crecieron y se complicaron, asÃ­ que la comunidad empezÃ³ a crear maneras de organizar el cÃ³digo en mÃ³dulos. Â¡La creatividad no faltÃ³! ğŸ¨

AquÃ­ tienes algunos ejemplos histÃ³ricos:

- **AMD**: uno de los primeros sistemas de mÃ³dulos, implementado con la biblioteca `require.js`.
- **CommonJS**: un sistema diseÃ±ado para Node.js, enfocado en el servidor.
- **UMD**: una soluciÃ³n "universal" para ser compatible con AMD y CommonJS.

Aunque estas soluciones ya son mÃ¡s historia que presente ğŸ“œ, todavÃ­a puedes encontrar scripts viejitos usÃ¡ndolas.

En 2015, JavaScript incorporÃ³ **mÃ³dulos modernos** como estÃ¡ndar oficial. Desde entonces, estos han evolucionado y ahora son compatibles con todos los navegadores principales ğŸŒ y con Node.js. Â¡AsÃ­ que llegÃ³ el momento de aprenderlos y sacarles el mÃ¡ximo provecho! ğŸ‰

## ğŸ“ Â¿QuÃ© son los mÃ³dulos?

Un **mÃ³dulo** es simplemente un archivo de JavaScript. ğŸ“ SÃ­, un archivo comÃºn y corriente. Lo genial es que los mÃ³dulos pueden "hablar" entre sÃ­ usando las palabras mÃ¡gicas `export` e `import`.

Â¿CÃ³mo funcionan?

- **export**: etiqueta las variables o funciones que quieres compartir con otros mÃ³dulos.
- **import**: permite usar esas funciones o variables en otro mÃ³dulo.

Por ejemplo, imaginemos que tienes un archivo llamado `sayHi.js` que exporta una funciÃ³n para saludar:

```js
// ğŸ“ sayHi.js
export function sayHi(user) {
  alert(`Hola, ${user}!`);
}
```

Ahora, otro archivo puede importarlo y usarlo:

```js
// ğŸ“ main.js
import { sayHi } from "./sayHi.js";

sayHi("Lucas"); // Muestra: Hola, Lucas!
```

Â¡AsÃ­ de simple! La directiva `import` busca el archivo indicado (`./sayHi.js` en este caso), lo carga y te da acceso a la funciÃ³n `sayHi`. ğŸš€

Para que esto funcione en el navegador, debemos decirle que estamos usando mÃ³dulos. Lo hacemos con el atributo `<script type="module">`. Por ejemplo:

<Tabs syncKey="pkg">
<TabItem label="say.js">

```js
export function sayHi(user) {
  return `Hello, ${user}!`;
}
```

</TabItem>
<TabItem label="index.html">

```html
<script type="module">
  import { sayHi } from "./sayHi.js";
  sayHi("Lucas");
</script>
```

</TabItem>

</Tabs>

El navegador automÃ¡ticamente encuentra y ejecuta el mÃ³dulo importado. âœ…

#### ğŸš¨ Â¡Cuidado con los mÃ³dulos y los archivos locales!

Los mÃ³dulos solo funcionan a travÃ©s de HTTP(s). Si intentas abrir tu archivo HTML directamente desde tu computadora (usando `file://`), las directivas `import` y `export` no funcionarÃ¡n. âŒ

Â¿QuÃ© hacer?
Usa un servidor local, como `static-server`, o extensiones como **Live Server** en VS Code. AsÃ­ todo funcionarÃ¡ como deberÃ­a. ğŸŒğŸ”§

## ğŸŒŸ CaracterÃ­sticas principales de los mÃ³dulos

Los mÃ³dulos tienen algunas diferencias importantes frente a los scripts â€œnormalesâ€. AquÃ­ te las explico:

#### 1. Siempre estÃ¡n en modo estricto

Cuando usas mÃ³dulos, JavaScript automÃ¡ticamente aplica el modo estricto. Esto significa que no puedes hacer cosas como usar variables sin declararlas. Por ejemplo:

```js
<script type="module">
  a = 5; // Error: Â¡debes declarar la variable primero!
</script>
```

#### 2. Alcance propio

Cada mÃ³dulo tiene su propio "mundo". ğŸŒ Las variables y funciones definidas en un mÃ³dulo no son visibles desde otros. Si necesitas compartir algo, debes usar export e import.

<Tabs syncKey="pkg">
<TabItem label="hello.js">

```js
alert(user); // no existe tal variable (cada mÃ³dulo tiene variables independientes)
```

</TabItem>
<TabItem label="user.js">

```js
let user = "John";
```

</TabItem>
<TabItem label="index.html">

```html
<!DOCTYPE html>
<script type="module" src="user.js"></script>
<script type="module" src="hello.js"></script>
```

</TabItem>

</Tabs>

Si no exportas nada, el mÃ³dulo serÃ¡ como un castillo cerrado ğŸ”’.

#### 3. EvaluaciÃ³n Ãºnica

El cÃ³digo de un mÃ³dulo solo se ejecuta una vez, incluso si se importa desde varios lugares. Eso significa que cualquier cosa que ocurra al cargar el mÃ³dulo (como mostrar un mensaje) sucede solo la primera vez. ğŸ•’

<Tabs syncKey="pkg">
<TabItem label="alert.js">

```js
alert("MÃ³dulo cargado!");
```

</TabItem>
<TabItem label="main.js">

```js
import "./alert.js"; // Muestra: MÃ³dulo cargado!
import "./alert.js"; // No muestra nada esta vez.
```

</TabItem>

</Tabs>

## ğŸ’¡ Â¡Trucos y consejos prÃ¡cticos!

#### 1. Configura tus mÃ³dulos

Puedes exportar objetos o funciones configurables. Por ejemplo, un mÃ³dulo `admin.js` podrÃ­a exportar un objeto vacÃ­o y luego configurarlo desde otro archivo:

<Tabs syncKey="pkg">
<TabItem label="admin.js">

```js
export let config = {};

export function sayHi() {
  alert(`Hola, ${config.user}!`);
}
```

</TabItem>
<TabItem label="init.js">

```js
import { config } from "./admin.js";
config.user = "Lucas";
```

</TabItem>

</Tabs>

#### 2. `import.meta`

El objeto `import.meta` te da informaciÃ³n sobre el mÃ³dulo actual, como su URL. Esto es Ãºtil para identificar desde dÃ³nde se estÃ¡ ejecutando el cÃ³digo. ğŸŒ

```js
<script type="module">
  console.log(import.meta.url); // Muestra la URL del script
</script>
```

#### 3. Evita usar `this`

En los mÃ³dulos, el nivel superior `this` es `undefined`. Esto es diferente de los scripts normales, donde `this` es el objeto global (`window` en navegadores). ğŸ§
