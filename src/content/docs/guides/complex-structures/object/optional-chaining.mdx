---
title: Encadenamiento opcional
---

El encadenamiento opcional (`?.`) es una herramienta poderosa y a **prueba de errores** que nos permite acceder de manera segura a propiedades, mÃ©todos y elementos de objetos, incluso si estos no existen. Si alguna parte de la cadena es `null` o `undefined`, el operador devuelve automÃ¡ticamente `undefined` en lugar de generar un error.

### Problema que resuelve â“

Cuando intentamos acceder a propiedades anidadas en un objeto que no estÃ¡ completamente definido, JavaScript lanza un error.

#### ğŸŒ Ejemplo clÃ¡sico

```js
let user = {}; // user no tiene la propiedad address

console.log(user.address.street); // âŒ Error: Cannot read property 'street' of undefined
```

Este error ocurre porque `user.address` es `undefined`, y al intentar acceder a `street`, JavaScript no sabe cÃ³mo continuar.

En muchos casos, en lugar de un error, quisiÃ©ramos un resultado seguro, como `undefined`, para representar que la informaciÃ³n no estÃ¡ disponible.

#### ğŸ’¡ Soluciones tradicionales

1. Usar condicionales:

```js
let street = user.address ? user.address.street : undefined;
console.log(street); // âœ… undefined
```

Pero esta soluciÃ³n no es muy elegante: repetimos `user.address` varias veces. ğŸ˜“

2. Utilizar el operador lÃ³gico `&&`:

```js
let street = user.address && user.address.street;
console.log(street); // âœ… undefined
```

Aunque mejora un poco, sigue siendo repetitivo y difÃ­cil de leer si la estructura es mÃ¡s profunda.

### Â¿CÃ³mo lo resuelve el encadenamiento opcional? ğŸŒŸ

El operador `?.` permite acceder a propiedades, mÃ©todos o elementos de forma segura. Si encuentra `null` o `undefined` en cualquier parte de la cadena, **detiene la evaluaciÃ³n** y devuelve `undefined`.

#### âœï¸ Ejemplo con encadenamiento opcional

```js
let user = {}; // El usuario no tiene la propiedad "address"

console.log(user?.address?.street); // âœ… undefined (sin errores)
```

AquÃ­, JavaScript verifica cada parte de la cadena:

1. Si `user` es `undefined` o `null`, devuelve `undefined`.
2. Si `user.address` es `undefined` o `null`, detiene la evaluaciÃ³n y devuelve `undefined`.
3. Solo si todas las partes existen, accede a `street`.

## Casos de uso prÃ¡cticos ğŸš€

### 1ï¸âƒ£ Acceso a propiedades dinÃ¡micas

Cuando trabajamos con datos anidados y no estamos seguros de que todas las propiedades existan.

```js
let user = {
  profile: {
    name: "Lucas",
  },
};

console.log(user?.profile?.name); // âœ… "Lucas"
console.log(user?.profile?.age); // âœ… undefined (sin errores)
```

### 2ï¸âƒ£ Llamadas a mÃ©todos opcionales

Con `?.()`, podemos llamar a mÃ©todos solo si existen.

```js
let userAdmin = {
  sayHi() {
    console.log("Hola, soy admin.");
  },
};

let userGuest = {}; // No tiene el mÃ©todo "sayHi"

userAdmin.sayHi?.(); // âœ… "Hola, soy admin."
userGuest.sayHi?.(); // âœ… No hace nada (sin errores)
```

### 3ï¸âƒ£ Acceso seguro a propiedades con corchetes

Si necesitamos usar nombres de propiedades dinÃ¡micos, el encadenamiento opcional tambiÃ©n funciona con corchetes `?.[]`.

```js
let key = "name";

let user1 = { name: "Lucas" };
let user2 = null; // Usuario inexistente

console.log(user1?.[key]); // âœ… "Lucas"
console.log(user2?.[key]); // âœ… undefined
```

### 4ï¸âƒ£ EliminaciÃ³n segura

Podemos usar delete con `?.` para evitar errores al intentar borrar propiedades que podrÃ­an no existir.

```js
let user = { name: "Lucas" };

delete user?.name; // âœ… Borra "name" si existe, sin errores.
delete user?.age; // âœ… No pasa nada (sin errores).
```

## ğŸš€ Ventajas clave del encadenamiento opcional

- **Evita errores innecesarios**: Elimina los tÃ­picos errores como `Cannot read property 'X' of undefined`.
- **CÃ³digo mÃ¡s limpio**: Evita duplicar verificaciones manuales con `if` o `&&`.
- **Ahorro de tiempo y esfuerzo**: Muy Ãºtil cuando trabajamos con datos anidados (como respuestas de API).

## ğŸ” Short-circuiting (Cortocircuito)

El operador `?.` detiene inmediatamente la evaluaciÃ³n si encuentra `null` o `undefined` en la parte izquierda. Esto no solo evita errores, sino que tambiÃ©n optimiza la ejecuciÃ³n al no procesar innecesariamente cÃ³digo adicional.

#### âœï¸ Ejemplo prÃ¡ctico:

```js
let user = null;
let x = 0;

// La funciÃ³n no se ejecuta porque user es null
user?.sayHi(x++);

console.log(x); // âœ… 0 (x no se incrementa)
```

## ğŸ“‹ Resumen de la sintaxis

El encadenamiento opcional tiene tres formas principales:

1. Acceso a propiedades:

```js
obj?.prop;
```

Devuelve `obj.prop` si `obj` existe, de lo contrario, `undefined`.

2. Acceso dinÃ¡mico a propiedades:

```js
obj?.[prop];
```

Devuelve `obj[prop]` si `obj` existe, de lo contrario, `undefined`.

3. Llamadas a mÃ©todos:

```js
obj.method?.();
```

Llama a `obj.method()` si existe, de lo contrario, devuelve `undefined`.

## âš ï¸ Consideraciones importantes

Aunque el encadenamiento opcional es muy Ãºtil, debemos usarlo con cuidado:

- Solo debe aplicarse donde sea aceptable que una parte del objeto no exista.
- No lo utilices para ocultar errores de programaciÃ³n, ya que podrÃ­a dificultar la detecciÃ³n de problemas lÃ³gicos en tu cÃ³digo.
