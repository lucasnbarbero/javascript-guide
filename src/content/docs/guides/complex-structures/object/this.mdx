---
title: Metodos de objetos
---

import { Aside } from "@astrojs/starlight/components";

Cuando trabajamos con objetos en JavaScript, no solo se trata de almacenar datos. Â¡TambiÃ©n pueden realizar acciones! ğŸ­ Los objetos suelen representar entidades del mundo real, como usuarios, Ã³rdenes, o cualquier cosa que quieras modelar.

Por ejemplo, aquÃ­ tenemos un usuario bÃ¡sico:

```js
let user = {
  name: "John",
  age: 30,
};
```

Pero un usuario no solo existe, tambiÃ©n _actÃºa_: puede iniciar sesiÃ³n, cerrar sesiÃ³n, o decir hola ğŸ‘‹. Estas acciones se implementan asignando funciones a las propiedades del objeto

### Ejemplos de mÃ©todos

EnseÃ±emos a nuestro usuario `user` a decir hola:

```js
let user = {
  name: "John",
  age: 30,
};

user.sayHi = function () {
  alert("Â¡Hola! ğŸ‘‹");
};

user.sayHi(); // Â¡Hola! ğŸ‘‹
```

AquÃ­, asignamos una funciÃ³n a la propiedad `sayHi`. Luego llamamos a esa funciÃ³n con `user.sayHi()`.
ğŸ‰ Â¡Listo! Nuestro usuario ahora puede hablar.

> **Una funciÃ³n asignada como propiedad de un objeto se llama mÃ©todo.**

Por lo tanto, en este caso, `sayHi` es un mÃ©todo del objeto `user`.

<Aside type="tip" title="ProgramaciÃ³n Orientada a Objetos">
  Cuando modelamos entidades del mundo real como objetos que contienen datos y
  mÃ©todos, estamos usando ProgramaciÃ³n Orientada a Objetos (POO).
</Aside>

## Sintaxis abreviada para mÃ©todos âœ‚ï¸

JavaScript ofrece una forma mÃ¡s corta y elegante de escribir mÃ©todos:

```js
// Ambos objetos hacen lo mismo:

user = {
  sayHi: function () {
    alert("Hello ğŸŒŸ");
  },
};

user = {
  sayHi() {
    alert("Hello ğŸŒŸ");
  },
};
```

ğŸ’¡ En la segunda versiÃ³n, omitimos `function` y usamos una sintaxis mÃ¡s compacta.
Aunque existen pequeÃ±as diferencias relacionadas con herencia, en la mayorÃ­a de los casos esta notaciÃ³n es la preferida.

## `this` en mÃ©todos ğŸ”

A menudo, los mÃ©todos necesitan acceder a la informaciÃ³n dentro del objeto al que pertenecen.

Por ejemplo, el mÃ©todo `sayHi()` podrÃ­a necesitar el nombre del usuario:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(this.name); // "this" se refiere al objeto actual
  },
};

user.sayHi(); // John
```

Â¿QuÃ© es `this`?

`this` es como un sÃºper poder ğŸ¦¸. Cuando llamamos a un mÃ©todo como `user.sayHi()`, el valor de this es el objeto antes del punto. En este caso, this es igual a user.

<Aside type="caution" title="Referenciar directamente al objeto">
  Aunque podrÃ­amos usar el nombre del objeto en lugar de `this`, hacerlo puede causar problemas:

```js
let user = {
  name: "John",
  sayHi() {
    alert(user.name); // Esto es menos flexible
  },
};
```

Si copiamos el objeto a otra variable, como aquÃ­:

```js
let admin = user;
user = null;

admin.sayHi(); // âŒ TypeError: No se puede leer 'name' de null
```

Â¡Boom! ğŸ’¥ Usar `this` evita este problema, porque siempre apunta al objeto actual.

</Aside>
