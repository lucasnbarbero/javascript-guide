---
title: Map y Set
---

import { Aside } from "@astrojs/starlight/components";

Hasta ahora, hemos aprendido sobre estas estructuras de datos:

- **Objetos**: ideales para colecciones de datos organizadas por claves.
- **Arrays**: perfectos para colecciones ordenadas de elementos.

Sin embargo, para algunos escenarios de la vida real, estas estructuras pueden quedarse cortas. Por eso tenemos a los poderosos **Map** y **Set**. ğŸš€

## ğŸ”‘ `Map`: La evoluciÃ³n de los objetos

Un `Map` es como un objeto, pero con superpoderes: permite usar **cualquier tipo de dato como clave**. Â¡Eso significa que no estÃ¡s limitado a strings o sÃ­mbolos! ğŸ‰

#### MÃ©todos y propiedades principales

- `new Map()`: Crea un nuevo mapa vacÃ­o.
- `map.set(clave, valor)`: Asocia un valor a una clave.
- `map.get(clave)`: Obtiene el valor asociado a la clave. Devuelve `undefined` si no existe.
- `map.has(clave)`: Verifica si una clave estÃ¡ en el mapa.
- `map.delete(clave)`: Elimina una clave y su valor.
- `map.clear()`: Limpia todo el contenido del mapa.
- `map.size`: Devuelve el nÃºmero de elementos en el mapa.

#### Ejemplo prÃ¡ctico

```js
let map = new Map();

map.set("1", "string"); // Clave: string
map.set(1, "number"); // Clave: nÃºmero
map.set(true, "boolean"); // Clave: booleano

console.log(map.get(1)); // "number"
console.log(map.get("1")); // "string"
console.log(map.size); // 3
```

ğŸš¨ **Nota importante:** A diferencia de los objetos, las claves en un Map no se convierten a cadenas automÃ¡ticamente. Â¡Esto da mÃ¡s control y flexibilidad! ğŸ”¥

<Aside type="tip" title="Evita usar map[clave]">
  Aunque tÃ©cnicamente puedes usar `map[clave]`, esto trata al mapa como un
  objeto normal, perdiendo las ventajas de `Map`. Usa siempre los mÃ©todos como
  `set` y `get` para trabajar correctamente. âœ…
</Aside>

### Â¿CuÃ¡ndo usar `Map` en lugar de un objeto?

1. **Cuando necesitas claves que no sean strings:** Un `Map` puede usar objetos, nÃºmeros, booleans, o cualquier otro tipo como claves, mientras que los objetos convierten todas las claves a strings.
2. **Cuando requieres un tamaÃ±o conocido:** Con `Map`, puedes usar la propiedad `.size` para obtener el nÃºmero de elementos directamente.
3. **Cuando necesitas iterar fÃ¡cilmente:** Los mÃ©todos de iteraciÃ³n como `map.keys()`, `map.values()`, y `map.entries()` son mÃ¡s cÃ³modos que iterar sobre objetos.

### Ejemplo: Contar concurrencias Ãºnicas

Imagina que estÃ¡s desarrollando una funcionalidad para analizar una lista de usuarios activos en una app. Necesitas saber cuÃ¡ntas veces se ha registrado cada usuario:

```js
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 1, name: "Alice" },
  { id: 3, name: "Charlie" },
  { id: 2, name: "Bob" },
];

const userMap = new Map();

// Contamos cuÃ¡ntas veces aparece cada usuario
users.forEach((user) => {
  const currentCount = userMap.get(user.id) || 0;
  userMap.set(user.id, currentCount + 1);
});

userMap.forEach((count, userId) => {
  console.log(`Usuario ${userId} se registrÃ³ ${count} veces.`);
});
// Resultado:
// Usuario 1 se registrÃ³ 2 veces.
// Usuario 2 se registrÃ³ 2 veces.
// Usuario 3 se registrÃ³ 1 vez.
```

## ğŸŒŸ `Set`: Â¡Solo valores Ãºnicos, por favor!

Un `Set` es una colecciÃ³n especial donde cada valor debe ser Ãºnico. Es perfecto para evitar duplicados sin necesidad de validar manualmente. Â¡Un salvavidas! ğŸ›Ÿ

#### MÃ©todos y propiedades principales

- `new Set([iterable])`: Crea un nuevo conjunto, opcionalmente inicializado con un iterable (como un array).
- `set.add(valor)`: Agrega un valor Ãºnico.
- `set.delete(valor)`: Elimina un valor. Devuelve true si existÃ­a, false si no.
- `set.has(valor)`: Verifica si un valor existe.
- `set.clear()`: Limpia todo el contenido del conjunto.
- `set.size`: Retorna la cantidad de elementos en el conjunto.

#### Ejemplo prÃ¡ctico

```js
let set = new Set();

set.add("ğŸ");
set.add("ğŸŒ");
set.add("ğŸ"); // Este valor no se duplicarÃ¡

console.log(set.size); // 2

for (let fruit of set) {
  console.log(fruit); // "ğŸ", "ğŸŒ"
}
```

### Â¿CuÃ¡ndo usar `Set` en lugar de un array?

1. **Cuando necesitas eliminar duplicados fÃ¡cilmente:** Un Set hace esto automÃ¡ticamente, sin necesidad de escribir lÃ³gica adicional.
2. **Cuando la unicidad es clave en tus datos:** Si tienes una lista donde cada valor debe ser Ãºnico (como nombres de usuario o correos), usa un Set.

### Ejemplo: Encontrar palabras Ãºnicas

Imagina que estÃ¡s creando una herramienta para analizar textos y necesitas extraer las palabras Ãºnicas de un pÃ¡rrafo:

```js
const paragraph = "JavaScript es increÃ­ble, y JavaScript es popular.";
const words = paragraph.toLowerCase().match(/\w+/g); // Convertimos a minÃºsculas y extraemos palabras

const uniqueWords = new Set(words);

console.log(uniqueWords);
// Resultado: Set { 'javascript', 'es', 'increÃ­ble', 'y', 'popular' }

// Convertimos el Set a un array
console.log([...uniqueWords]);
// Resultado: ['javascript', 'es', 'increÃ­ble', 'y', 'popular']
```

## ğŸ”„ Iterar sobre `Map` y `Set`

Ambas estructuras soportan varias formas de iteraciÃ³n. AquÃ­ algunos ejemplos:

#### `Map`

```js
let recipeMap = new Map([
  ["pepino", 500],
  ["tomates", 350],
  ["cebollas", 50],
]);

// Claves
for (let vegetable of recipeMap.keys()) {
  console.log(vegetable); // pepino, tomates, cebollas
}

// Valores
for (let amount of recipeMap.values()) {
  console.log(amount); // 500, 350, 50
}

// Entradas [clave, valor]
for (let entry of recipeMap.entries()) {
  console.log(entry); // ["pepino", 500] ...
}
```

#### `Set`

```js
let fruits = new Set(["ğŸ", "ğŸŒ", "ğŸ‡"]);

for (let fruit of fruits) {
  console.log(fruit); // "ğŸ", "ğŸŒ", "ğŸ‡"
}

fruits.forEach((value) => {
  console.log(value); // "ğŸ", "ğŸŒ", "ğŸ‡"
});
```

## Comparativa PrÃ¡ctica

AquÃ­ tienes una guÃ­a rÃ¡pida para decidir cuÃ¡ndo usar `Map`, `Set`, objetos o arrays:

| Necesidad                   | Usa esto | Por quÃ©                                                              |
| --------------------------- | -------- | -------------------------------------------------------------------- |
| Almacenar pares clave/valor | `Map`    | Soporta cualquier tipo de clave y mÃ©todos mÃ¡s prÃ¡cticos.             |
| ColecciÃ³n de datos Ãºnicos   | `Set`    | Garantiza unicidad de valores automÃ¡ticamente.                       |
| RelaciÃ³n clave/valor simple | `Objeto` | MÃ¡s ligero si las claves son strings y no necesitas iteraciÃ³n fÃ¡cil. |
| ColecciÃ³n ordenada de datos | `Array`  | Ideal para listas y operaciones como filtro o mapeo.                 |

## Ejempo Combinado

Supongamos que estamos desarrollando un sistema para registrar eventos Ãºnicos y su frecuencia.

Necesitamos:

1. **Evitar duplicados en los nombres de los eventos.**
2. **Contar cuÃ¡ntas veces ocurre cada evento**

```js
const events = ["login", "viewPage", "login", "logout", "viewPage", "login"];

// Evitamos duplicados
const uniqueEvents = new Set(events);

// Contamos frecuencia de cada evento
const eventCount = new Map();

events.forEach((event) => {
  const currentCount = eventCount.get(event) || 0;
  eventCount.set(event, currentCount + 1);
});

console.log("Eventos Ãºnicos:", [...uniqueEvents]);
// Resultado: ['login', 'viewPage', 'logout']

console.log("Frecuencia de eventos:");
eventCount.forEach((count, event) => {
  console.log(`${event}: ${count}`);
});
// Resultado:
// login: 3
// viewPage: 2
// logout: 1
```

## âœ¨ Resumen

#### Map ğŸ—ºï¸

- Claves de cualquier tipo (Â¡incluso objetos!).
- MÃ©todos Ãºtiles: `set`, `get`, `has`, `delete`.
- Ideal cuando necesitas pares clave-valor con tipos variados.

#### Set âœ…

- Solo almacena valores Ãºnicos.
- MÃ©todos clave: `add`, `has`, `delete`.
- Perfecto para eliminar duplicados o mantener colecciones Ãºnicas.
